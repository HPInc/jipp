// Copyright 2018 HP Development Company, L.P.
// SPDX-License-Identifier: MIT
//
// DO NOT MODIFY. Code is auto-generated by genTypes.py. Content taken from registry at
// https://www.iana.org/assignments/ipp-registrations/ipp-registrations.xml, updated on 2018-04-06
@file:Suppress("MaxLineLength", "WildcardImport")

package com.hp.jipp.pwg

import com.hp.jipp.encoding.* // ktlint-disable no-wildcard-imports

/**
 * Data object corresponding to a "finishings-col" collection as defined in:
 * [PWG5100.1](http://ftp.pwg.org/pub/pwg/candidates/cs-ippfinishings10-20010205-5100.1.pdf),
 * [PWG5100.3](http://ftp.pwg.org/pub/pwg/candidates/cs-ippprodprint10-20010212-5100.3.pdf).
 */
@Suppress("RedundantCompanionReference", "unused")
data class FinishingsCol
@JvmOverloads constructor(
    val baling: Baling? = null,
    val binding: Binding? = null,
    val coating: Coating? = null,
    val covering: Covering? = null,
    /** May contain any keyword from [FinishingTemplate] or a name. */
    val finishingTemplate: String? = null,
    val folding: List<Folding>? = null,
    /** May contain any keyword from [ImpositionTemplate] or a name. */
    val impositionTemplate: String? = null,
    val laminating: Laminating? = null,
    val mediaSheetsSupported: IntRange? = null,
    val mediaSize: MediaSize? = null,
    /** May contain any keyword from [Media]. */
    val mediaSizeName: String? = null,
    val punching: Punching? = null,
    val stitching: Stitching? = null,
    val trimming: List<Trimming>? = null,
    /** Original parameters received, if any. */
    val _original: List<Attribute<*>>? = null
) : AttributeCollection {

    /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
    override val attributes: List<Attribute<*>> by lazy {
        _original ?: listOfNotNull(
            baling?.let { Members.baling.of(it) },
            binding?.let { Members.binding.of(it) },
            coating?.let { Members.coating.of(it) },
            covering?.let { Members.covering.of(it) },
            finishingTemplate?.let { Members.finishingTemplate.of(it) },
            folding?.let { Members.folding.of(it) },
            impositionTemplate?.let { Members.impositionTemplate.of(it) },
            laminating?.let { Members.laminating.of(it) },
            mediaSheetsSupported?.let { Members.mediaSheetsSupported.of(it) },
            mediaSize?.let { Members.mediaSize.of(it) },
            mediaSizeName?.let { Members.mediaSizeName.of(it) },
            punching?.let { Members.punching.of(it) },
            stitching?.let { Members.stitching.of(it) },
            trimming?.let { Members.trimming.of(it) }
        )
    }

    /** Type for attributes of this collection */
    class Type(override val name: String) : AttributeCollection.Type<FinishingsCol>(Members)

    /** All member names as strings. */
    object Name {
        /** "baling" member name */
        const val baling = "baling"
        /** "binding" member name */
        const val binding = "binding"
        /** "coating" member name */
        const val coating = "coating"
        /** "covering" member name */
        const val covering = "covering"
        /** "finishing-template" member name */
        const val finishingTemplate = "finishing-template"
        /** "folding" member name */
        const val folding = "folding"
        /** "imposition-template" member name */
        const val impositionTemplate = "imposition-template"
        /** "laminating" member name */
        const val laminating = "laminating"
        /** "media-sheets-supported" member name */
        const val mediaSheetsSupported = "media-sheets-supported"
        /** "media-size" member name */
        const val mediaSize = "media-size"
        /** "media-size-name" member name */
        const val mediaSizeName = "media-size-name"
        /** "punching" member name */
        const val punching = "punching"
        /** "stitching" member name */
        const val stitching = "stitching"
        /** "trimming" member name */
        const val trimming = "trimming"
    }

    companion object Members : AttributeCollection.Converter<FinishingsCol> {
        override fun convert(attributes: List<Attribute<*>>): FinishingsCol =
            FinishingsCol(
                extractOne(attributes, baling),
                extractOne(attributes, binding),
                extractOne(attributes, coating),
                extractOne(attributes, covering),
                extractOne(attributes, finishingTemplate),
                extractAll(attributes, folding),
                extractOne(attributes, impositionTemplate),
                extractOne(attributes, laminating),
                extractOne(attributes, mediaSheetsSupported),
                extractOne(attributes, mediaSize),
                extractOne(attributes, mediaSizeName),
                extractOne(attributes, punching),
                extractOne(attributes, stitching),
                extractAll(attributes, trimming),
                _original = attributes)
        /**
         * "baling" member type.
         */
        @JvmField val baling = Baling.Type(Name.baling)
        /**
         * "binding" member type.
         */
        @JvmField val binding = Binding.Type(Name.binding)
        /**
         * "coating" member type.
         */
        @JvmField val coating = Coating.Type(Name.coating)
        /**
         * "covering" member type.
         */
        @JvmField val covering = Covering.Type(Name.covering)
        /**
         * "finishing-template" member type.
         * May contain any keyword from [FinishingTemplate] or a name.
         */
        @JvmField val finishingTemplate = KeywordType(Name.finishingTemplate)
        /**
         * "folding" member type.
         */
        @JvmField val folding = Folding.Type(Name.folding)
        /**
         * "imposition-template" member type.
         * May contain any keyword from [ImpositionTemplate] or a name.
         */
        @JvmField val impositionTemplate = KeywordType(Name.impositionTemplate)
        /**
         * "laminating" member type.
         */
        @JvmField val laminating = Laminating.Type(Name.laminating)
        /**
         * "media-sheets-supported" member type.
         */
        @JvmField val mediaSheetsSupported = IntRangeType(Name.mediaSheetsSupported)
        /**
         * "media-size" member type.
         */
        @JvmField val mediaSize = MediaSize.Type(Name.mediaSize)
        /**
         * "media-size-name" member type.
         * May contain any keyword from [Media].
         */
        @JvmField val mediaSizeName = KeywordType(Name.mediaSizeName)
        /**
         * "punching" member type.
         */
        @JvmField val punching = Punching.Type(Name.punching)
        /**
         * "stitching" member type.
         */
        @JvmField val stitching = Stitching.Type(Name.stitching)
        /**
         * "trimming" member type.
         */
        @JvmField val trimming = Trimming.Type(Name.trimming)
    }

    /**
     * Data object corresponding to a "baling" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Baling
    @JvmOverloads constructor(
        /** May contain any keyword from [BalingType] or a name. */
        val balingType: String? = null,
        /** May contain any keyword from [BalingWhen]. */
        val balingWhen: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                balingType?.let { Members.balingType.of(it) },
                balingWhen?.let { Members.balingWhen.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Baling>(Members)

        /** All member names as strings. */
        object Name {
            /** "baling-type" member name */
            const val balingType = "baling-type"
            /** "baling-when" member name */
            const val balingWhen = "baling-when"
        }

        companion object Members : AttributeCollection.Converter<Baling> {
            override fun convert(attributes: List<Attribute<*>>): Baling =
                Baling(
                    extractOne(attributes, balingType),
                    extractOne(attributes, balingWhen),
                    _original = attributes)
            /**
             * "baling-type" member type.
             * May contain any keyword from [BalingType] or a name.
             */
            @JvmField val balingType = KeywordType(Name.balingType)
            /**
             * "baling-when" member type.
             * May contain any keyword from [BalingWhen].
             */
            @JvmField val balingWhen = KeywordType(Name.balingWhen)
        }
    }

    /**
     * Data object corresponding to a "binding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Binding
    @JvmOverloads constructor(
        /** May contain any keyword from [BindingReferenceEdge]. */
        val bindingReferenceEdge: String? = null,
        /** May contain any keyword from [BindingType] or a name. */
        val bindingType: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                bindingReferenceEdge?.let { Members.bindingReferenceEdge.of(it) },
                bindingType?.let { Members.bindingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Binding>(Members)

        /** All member names as strings. */
        object Name {
            /** "binding-reference-edge" member name */
            const val bindingReferenceEdge = "binding-reference-edge"
            /** "binding-type" member name */
            const val bindingType = "binding-type"
        }

        companion object Members : AttributeCollection.Converter<Binding> {
            override fun convert(attributes: List<Attribute<*>>): Binding =
                Binding(
                    extractOne(attributes, bindingReferenceEdge),
                    extractOne(attributes, bindingType),
                    _original = attributes)
            /**
             * "binding-reference-edge" member type.
             * May contain any keyword from [BindingReferenceEdge].
             */
            @JvmField val bindingReferenceEdge = KeywordType(Name.bindingReferenceEdge)
            /**
             * "binding-type" member type.
             * May contain any keyword from [BindingType] or a name.
             */
            @JvmField val bindingType = KeywordType(Name.bindingType)
        }
    }

    /**
     * Data object corresponding to a "coating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Coating
    @JvmOverloads constructor(
        /** May contain any keyword from [CoatingSides]. */
        val coatingSides: String? = null,
        /** May contain any keyword from [CoatingType] or a name. */
        val coatingType: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                coatingSides?.let { Members.coatingSides.of(it) },
                coatingType?.let { Members.coatingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Coating>(Members)

        /** All member names as strings. */
        object Name {
            /** "coating-sides" member name */
            const val coatingSides = "coating-sides"
            /** "coating-type" member name */
            const val coatingType = "coating-type"
        }

        companion object Members : AttributeCollection.Converter<Coating> {
            override fun convert(attributes: List<Attribute<*>>): Coating =
                Coating(
                    extractOne(attributes, coatingSides),
                    extractOne(attributes, coatingType),
                    _original = attributes)
            /**
             * "coating-sides" member type.
             * May contain any keyword from [CoatingSides].
             */
            @JvmField val coatingSides = KeywordType(Name.coatingSides)
            /**
             * "coating-type" member type.
             * May contain any keyword from [CoatingType] or a name.
             */
            @JvmField val coatingType = KeywordType(Name.coatingType)
        }
    }

    /**
     * Data object corresponding to a "covering" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Covering
    @JvmOverloads constructor(
        /** May contain any keyword from [CoveringName] or a name. */
        val coveringName: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                coveringName?.let { Members.coveringName.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Covering>(Members)

        /** All member names as strings. */
        object Name {
            /** "covering-name" member name */
            const val coveringName = "covering-name"
        }

        companion object Members : AttributeCollection.Converter<Covering> {
            override fun convert(attributes: List<Attribute<*>>): Covering =
                Covering(
                    extractOne(attributes, coveringName),
                    _original = attributes)
            /**
             * "covering-name" member type.
             * May contain any keyword from [CoveringName] or a name.
             */
            @JvmField val coveringName = KeywordType(Name.coveringName)
        }
    }

    /**
     * Data object corresponding to a "folding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Folding
    @JvmOverloads constructor(
        /** May contain any keyword from [FoldingDirection]. */
        val foldingDirection: String? = null,
        val foldingOffset: Int? = null,
        /** May contain any keyword from [FoldingReferenceEdge]. */
        val foldingReferenceEdge: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                foldingDirection?.let { Members.foldingDirection.of(it) },
                foldingOffset?.let { Members.foldingOffset.of(it) },
                foldingReferenceEdge?.let { Members.foldingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Folding>(Members)

        /** All member names as strings. */
        object Name {
            /** "folding-direction" member name */
            const val foldingDirection = "folding-direction"
            /** "folding-offset" member name */
            const val foldingOffset = "folding-offset"
            /** "folding-reference-edge" member name */
            const val foldingReferenceEdge = "folding-reference-edge"
        }

        companion object Members : AttributeCollection.Converter<Folding> {
            override fun convert(attributes: List<Attribute<*>>): Folding =
                Folding(
                    extractOne(attributes, foldingDirection),
                    extractOne(attributes, foldingOffset),
                    extractOne(attributes, foldingReferenceEdge),
                    _original = attributes)
            /**
             * "folding-direction" member type.
             * May contain any keyword from [FoldingDirection].
             */
            @JvmField val foldingDirection = KeywordType(Name.foldingDirection)
            /**
             * "folding-offset" member type.
             */
            @JvmField val foldingOffset = IntType(Name.foldingOffset)
            /**
             * "folding-reference-edge" member type.
             * May contain any keyword from [FoldingReferenceEdge].
             */
            @JvmField val foldingReferenceEdge = KeywordType(Name.foldingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "laminating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Laminating
    @JvmOverloads constructor(
        /** May contain any keyword from [LaminatingSides]. */
        val laminatingSides: String? = null,
        /** May contain any keyword from [LaminatingType] or a name. */
        val laminatingType: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                laminatingSides?.let { Members.laminatingSides.of(it) },
                laminatingType?.let { Members.laminatingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Laminating>(Members)

        /** All member names as strings. */
        object Name {
            /** "laminating-sides" member name */
            const val laminatingSides = "laminating-sides"
            /** "laminating-type" member name */
            const val laminatingType = "laminating-type"
        }

        companion object Members : AttributeCollection.Converter<Laminating> {
            override fun convert(attributes: List<Attribute<*>>): Laminating =
                Laminating(
                    extractOne(attributes, laminatingSides),
                    extractOne(attributes, laminatingType),
                    _original = attributes)
            /**
             * "laminating-sides" member type.
             * May contain any keyword from [LaminatingSides].
             */
            @JvmField val laminatingSides = KeywordType(Name.laminatingSides)
            /**
             * "laminating-type" member type.
             * May contain any keyword from [LaminatingType] or a name.
             */
            @JvmField val laminatingType = KeywordType(Name.laminatingType)
        }
    }

    /**
     * Data object corresponding to a "media-size" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class MediaSize
    @JvmOverloads constructor(
        val xDimension: Int? = null,
        val yDimension: Int? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                xDimension?.let { Members.xDimension.of(it) },
                yDimension?.let { Members.yDimension.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<MediaSize>(Members)

        /** All member names as strings. */
        object Name {
            /** "x-dimension" member name */
            const val xDimension = "x-dimension"
            /** "y-dimension" member name */
            const val yDimension = "y-dimension"
        }

        companion object Members : AttributeCollection.Converter<MediaSize> {
            override fun convert(attributes: List<Attribute<*>>): MediaSize =
                MediaSize(
                    extractOne(attributes, xDimension),
                    extractOne(attributes, yDimension),
                    _original = attributes)
            /**
             * "x-dimension" member type.
             */
            @JvmField val xDimension = IntType(Name.xDimension)
            /**
             * "y-dimension" member type.
             */
            @JvmField val yDimension = IntType(Name.yDimension)
        }
    }

    /**
     * Data object corresponding to a "punching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Punching
    @JvmOverloads constructor(
        val punchingLocations: List<Int>? = null,
        val punchingOffset: Int? = null,
        /** May contain any keyword from [PunchingReferenceEdge]. */
        val punchingReferenceEdge: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                punchingLocations?.let { Members.punchingLocations.of(it) },
                punchingOffset?.let { Members.punchingOffset.of(it) },
                punchingReferenceEdge?.let { Members.punchingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Punching>(Members)

        /** All member names as strings. */
        object Name {
            /** "punching-locations" member name */
            const val punchingLocations = "punching-locations"
            /** "punching-offset" member name */
            const val punchingOffset = "punching-offset"
            /** "punching-reference-edge" member name */
            const val punchingReferenceEdge = "punching-reference-edge"
        }

        companion object Members : AttributeCollection.Converter<Punching> {
            override fun convert(attributes: List<Attribute<*>>): Punching =
                Punching(
                    extractAll(attributes, punchingLocations),
                    extractOne(attributes, punchingOffset),
                    extractOne(attributes, punchingReferenceEdge),
                    _original = attributes)
            /**
             * "punching-locations" member type.
             */
            @JvmField val punchingLocations = IntType(Name.punchingLocations)
            /**
             * "punching-offset" member type.
             */
            @JvmField val punchingOffset = IntType(Name.punchingOffset)
            /**
             * "punching-reference-edge" member type.
             * May contain any keyword from [PunchingReferenceEdge].
             */
            @JvmField val punchingReferenceEdge = KeywordType(Name.punchingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "stitching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Stitching
    @JvmOverloads constructor(
        val stitchingAngle: Int? = null,
        val stitchingLocations: List<Int>? = null,
        /** May contain any keyword from [StitchingMethod]. */
        val stitchingMethod: String? = null,
        val stitchingOffset: Int? = null,
        /** May contain any keyword from [StitchingReferenceEdge]. */
        val stitchingReferenceEdge: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                stitchingAngle?.let { Members.stitchingAngle.of(it) },
                stitchingLocations?.let { Members.stitchingLocations.of(it) },
                stitchingMethod?.let { Members.stitchingMethod.of(it) },
                stitchingOffset?.let { Members.stitchingOffset.of(it) },
                stitchingReferenceEdge?.let { Members.stitchingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Stitching>(Members)

        /** All member names as strings. */
        object Name {
            /** "stitching-angle" member name */
            const val stitchingAngle = "stitching-angle"
            /** "stitching-locations" member name */
            const val stitchingLocations = "stitching-locations"
            /** "stitching-method" member name */
            const val stitchingMethod = "stitching-method"
            /** "stitching-offset" member name */
            const val stitchingOffset = "stitching-offset"
            /** "stitching-reference-edge" member name */
            const val stitchingReferenceEdge = "stitching-reference-edge"
        }

        companion object Members : AttributeCollection.Converter<Stitching> {
            override fun convert(attributes: List<Attribute<*>>): Stitching =
                Stitching(
                    extractOne(attributes, stitchingAngle),
                    extractAll(attributes, stitchingLocations),
                    extractOne(attributes, stitchingMethod),
                    extractOne(attributes, stitchingOffset),
                    extractOne(attributes, stitchingReferenceEdge),
                    _original = attributes)
            /**
             * "stitching-angle" member type.
             */
            @JvmField val stitchingAngle = IntType(Name.stitchingAngle)
            /**
             * "stitching-locations" member type.
             */
            @JvmField val stitchingLocations = IntType(Name.stitchingLocations)
            /**
             * "stitching-method" member type.
             * May contain any keyword from [StitchingMethod].
             */
            @JvmField val stitchingMethod = KeywordType(Name.stitchingMethod)
            /**
             * "stitching-offset" member type.
             */
            @JvmField val stitchingOffset = IntType(Name.stitchingOffset)
            /**
             * "stitching-reference-edge" member type.
             * May contain any keyword from [StitchingReferenceEdge].
             */
            @JvmField val stitchingReferenceEdge = KeywordType(Name.stitchingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "trimming" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Trimming
    @JvmOverloads constructor(
        val trimmingOffset: Int? = null,
        /** May contain any keyword from [TrimmingReferenceEdge]. */
        val trimmingReferenceEdge: String? = null,
        /** May contain any keyword from [TrimmingType] or a name. */
        val trimmingType: String? = null,
        /** May contain any keyword from [TrimmingWhen]. */
        val trimmingWhen: String? = null,
        /** Original parameters received, if any. */
        val _original: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the [_original] attribute list (if it exists). */
        override val attributes: List<Attribute<*>> by lazy {
            _original ?: listOfNotNull(
                trimmingOffset?.let { Members.trimmingOffset.of(it) },
                trimmingReferenceEdge?.let { Members.trimmingReferenceEdge.of(it) },
                trimmingType?.let { Members.trimmingType.of(it) },
                trimmingWhen?.let { Members.trimmingWhen.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Trimming>(Members)

        /** All member names as strings. */
        object Name {
            /** "trimming-offset" member name */
            const val trimmingOffset = "trimming-offset"
            /** "trimming-reference-edge" member name */
            const val trimmingReferenceEdge = "trimming-reference-edge"
            /** "trimming-type" member name */
            const val trimmingType = "trimming-type"
            /** "trimming-when" member name */
            const val trimmingWhen = "trimming-when"
        }

        companion object Members : AttributeCollection.Converter<Trimming> {
            override fun convert(attributes: List<Attribute<*>>): Trimming =
                Trimming(
                    extractOne(attributes, trimmingOffset),
                    extractOne(attributes, trimmingReferenceEdge),
                    extractOne(attributes, trimmingType),
                    extractOne(attributes, trimmingWhen),
                    _original = attributes)
            /**
             * "trimming-offset" member type.
             */
            @JvmField val trimmingOffset = IntType(Name.trimmingOffset)
            /**
             * "trimming-reference-edge" member type.
             * May contain any keyword from [TrimmingReferenceEdge].
             */
            @JvmField val trimmingReferenceEdge = KeywordType(Name.trimmingReferenceEdge)
            /**
             * "trimming-type" member type.
             * May contain any keyword from [TrimmingType] or a name.
             */
            @JvmField val trimmingType = KeywordType(Name.trimmingType)
            /**
             * "trimming-when" member type.
             * May contain any keyword from [TrimmingWhen].
             */
            @JvmField val trimmingWhen = KeywordType(Name.trimmingWhen)
        }
    }
}
