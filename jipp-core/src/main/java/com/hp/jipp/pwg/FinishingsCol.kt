// Copyright 2018 HP Development Company, L.P.
// SPDX-License-Identifier: MIT
//
// DO NOT MODIFY. Code is auto-generated by genTypes.py. Content taken from registry at
// https://www.iana.org/assignments/ipp-registrations/ipp-registrations.xml, updated on 2018-04-06
@file:Suppress("MaxLineLength", "WildcardImport")

package com.hp.jipp.pwg

import com.hp.jipp.encoding.* // ktlint-disable no-wildcard-imports

/**
 * Data object corresponding to a "finishings-col" collection as defined in:
 * [PWG5100.1](http://ftp.pwg.org/pub/pwg/candidates/cs-ippfinishings10-20010205-5100.1.pdf),
 * [PWG5100.3](http://ftp.pwg.org/pub/pwg/candidates/cs-ippprodprint10-20010212-5100.3.pdf).
 */
@Suppress("RedundantCompanionReference", "unused")
data class FinishingsCol
@JvmOverloads constructor(
    val baling: Baling? = null,
    val binding: Binding? = null,
    val coating: Coating? = null,
    val covering: Covering? = null,
    /** May contain any keyword from [FinishingTemplate] or a name. */
    val finishingTemplate: String? = null,
    val folding: List<Folding>? = null,
    /** May contain any keyword from [ImpositionTemplate] or a name. */
    val impositionTemplate: String? = null,
    val laminating: Laminating? = null,
    val mediaSheetsSupported: IntRange? = null,
    val mediaSize: MediaSize? = null,
    /** May contain any keyword from [Media]. */
    val mediaSizeName: String? = null,
    val punching: Punching? = null,
    val stitching: Stitching? = null,
    val trimming: List<Trimming>? = null,
    /** Encoded form, if known. */
    val _encoded: List<Attribute<*>>? = null
) : AttributeCollection {

    /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
    override val attributes: List<Attribute<*>> by lazy {
        _encoded ?: listOfNotNull(
            baling?.let { Members.baling.of(it) },
            binding?.let { Members.binding.of(it) },
            coating?.let { Members.coating.of(it) },
            covering?.let { Members.covering.of(it) },
            finishingTemplate?.let { Members.finishingTemplate.of(it) },
            folding?.let { Members.folding.of(it) },
            impositionTemplate?.let { Members.impositionTemplate.of(it) },
            laminating?.let { Members.laminating.of(it) },
            mediaSheetsSupported?.let { Members.mediaSheetsSupported.of(it) },
            mediaSize?.let { Members.mediaSize.of(it) },
            mediaSizeName?.let { Members.mediaSizeName.of(it) },
            punching?.let { Members.punching.of(it) },
            stitching?.let { Members.stitching.of(it) },
            trimming?.let { Members.trimming.of(it) }
        )
    }

    /** Type for attributes of this collection */
    class Type(override val name: String) : AttributeCollection.Type<FinishingsCol>(Members)

    /** All member names as strings. */
    object Name {
        /** "baling" member name */
        const val baling = "baling"
        /** "binding" member name */
        const val binding = "binding"
        /** "coating" member name */
        const val coating = "coating"
        /** "covering" member name */
        const val covering = "covering"
        /** "finishing-template" member name */
        const val finishingTemplate = "finishing-template"
        /** "folding" member name */
        const val folding = "folding"
        /** "imposition-template" member name */
        const val impositionTemplate = "imposition-template"
        /** "laminating" member name */
        const val laminating = "laminating"
        /** "media-sheets-supported" member name */
        const val mediaSheetsSupported = "media-sheets-supported"
        /** "media-size" member name */
        const val mediaSize = "media-size"
        /** "media-size-name" member name */
        const val mediaSizeName = "media-size-name"
        /** "punching" member name */
        const val punching = "punching"
        /** "stitching" member name */
        const val stitching = "stitching"
        /** "trimming" member name */
        const val trimming = "trimming"
    }

    /** Builder for immutable [FinishingsCol] objects. */
    class Builder() {
        /** Constructs a new [Builder] pre-initialized with values in [source]. */
        constructor(source: FinishingsCol) : this() {
            baling = source.baling
            binding = source.binding
            coating = source.coating
            covering = source.covering
            finishingTemplate = source.finishingTemplate
            folding = source.folding
            impositionTemplate = source.impositionTemplate
            laminating = source.laminating
            mediaSheetsSupported = source.mediaSheetsSupported
            mediaSize = source.mediaSize
            mediaSizeName = source.mediaSizeName
            punching = source.punching
            stitching = source.stitching
            trimming = source.trimming
        }
        var baling: Baling? = null
        var binding: Binding? = null
        var coating: Coating? = null
        var covering: Covering? = null
        /** May contain any keyword from [FinishingTemplate] or a name. */
        var finishingTemplate: String? = null
        var folding: List<Folding>? = null
        /** May contain any keyword from [ImpositionTemplate] or a name. */
        var impositionTemplate: String? = null
        var laminating: Laminating? = null
        var mediaSheetsSupported: IntRange? = null
        var mediaSize: MediaSize? = null
        /** May contain any keyword from [Media]. */
        var mediaSizeName: String? = null
        var punching: Punching? = null
        var stitching: Stitching? = null
        var trimming: List<Trimming>? = null

        /** Return a new [FinishingsCol] object containing all values initialized in this builder. */
        fun build() = FinishingsCol(
            baling,
            binding,
            coating,
            covering,
            finishingTemplate,
            folding,
            impositionTemplate,
            laminating,
            mediaSheetsSupported,
            mediaSize,
            mediaSizeName,
            punching,
            stitching,
            trimming
        )
    }

    companion object Members : AttributeCollection.Converter<FinishingsCol> {
        override fun convert(attributes: List<Attribute<*>>): FinishingsCol =
            FinishingsCol(
                extractOne(attributes, baling),
                extractOne(attributes, binding),
                extractOne(attributes, coating),
                extractOne(attributes, covering),
                extractOne(attributes, finishingTemplate),
                extractAll(attributes, folding),
                extractOne(attributes, impositionTemplate),
                extractOne(attributes, laminating),
                extractOne(attributes, mediaSheetsSupported),
                extractOne(attributes, mediaSize),
                extractOne(attributes, mediaSizeName),
                extractOne(attributes, punching),
                extractOne(attributes, stitching),
                extractAll(attributes, trimming),
                _encoded = attributes)
        /**
         * "baling" member type.
         */
        @JvmField val baling = Baling.Type(Name.baling)
        /**
         * "binding" member type.
         */
        @JvmField val binding = Binding.Type(Name.binding)
        /**
         * "coating" member type.
         */
        @JvmField val coating = Coating.Type(Name.coating)
        /**
         * "covering" member type.
         */
        @JvmField val covering = Covering.Type(Name.covering)
        /**
         * "finishing-template" member type.
         * May contain any keyword from [FinishingTemplate] or a name.
         */
        @JvmField val finishingTemplate = KeywordType(Name.finishingTemplate)
        /**
         * "folding" member type.
         */
        @JvmField val folding = Folding.Type(Name.folding)
        /**
         * "imposition-template" member type.
         * May contain any keyword from [ImpositionTemplate] or a name.
         */
        @JvmField val impositionTemplate = KeywordType(Name.impositionTemplate)
        /**
         * "laminating" member type.
         */
        @JvmField val laminating = Laminating.Type(Name.laminating)
        /**
         * "media-sheets-supported" member type.
         */
        @JvmField val mediaSheetsSupported = IntRangeType(Name.mediaSheetsSupported)
        /**
         * "media-size" member type.
         */
        @JvmField val mediaSize = MediaSize.Type(Name.mediaSize)
        /**
         * "media-size-name" member type.
         * May contain any keyword from [Media].
         */
        @JvmField val mediaSizeName = KeywordType(Name.mediaSizeName)
        /**
         * "punching" member type.
         */
        @JvmField val punching = Punching.Type(Name.punching)
        /**
         * "stitching" member type.
         */
        @JvmField val stitching = Stitching.Type(Name.stitching)
        /**
         * "trimming" member type.
         */
        @JvmField val trimming = Trimming.Type(Name.trimming)
    }

    /**
     * Data object corresponding to a "baling" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Baling
    @JvmOverloads constructor(
        /** May contain any keyword from [BalingType] or a name. */
        val balingType: String? = null,
        /** May contain any keyword from [BalingWhen]. */
        val balingWhen: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                balingType?.let { Members.balingType.of(it) },
                balingWhen?.let { Members.balingWhen.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Baling>(Members)

        /** All member names as strings. */
        object Name {
            /** "baling-type" member name */
            const val balingType = "baling-type"
            /** "baling-when" member name */
            const val balingWhen = "baling-when"
        }

        /** Builder for immutable [Baling] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Baling) : this() {
                balingType = source.balingType
                balingWhen = source.balingWhen
            }
            /** May contain any keyword from [BalingType] or a name. */
            var balingType: String? = null
            /** May contain any keyword from [BalingWhen]. */
            var balingWhen: String? = null

            /** Return a new [Baling] object containing all values initialized in this builder. */
            fun build() = Baling(
                balingType,
                balingWhen
            )
        }

        companion object Members : AttributeCollection.Converter<Baling> {
            override fun convert(attributes: List<Attribute<*>>): Baling =
                Baling(
                    extractOne(attributes, balingType),
                    extractOne(attributes, balingWhen),
                    _encoded = attributes)
            /**
             * "baling-type" member type.
             * May contain any keyword from [BalingType] or a name.
             */
            @JvmField val balingType = KeywordType(Name.balingType)
            /**
             * "baling-when" member type.
             * May contain any keyword from [BalingWhen].
             */
            @JvmField val balingWhen = KeywordType(Name.balingWhen)
        }
    }

    /**
     * Data object corresponding to a "binding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Binding
    @JvmOverloads constructor(
        /** May contain any keyword from [BindingReferenceEdge]. */
        val bindingReferenceEdge: String? = null,
        /** May contain any keyword from [BindingType] or a name. */
        val bindingType: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                bindingReferenceEdge?.let { Members.bindingReferenceEdge.of(it) },
                bindingType?.let { Members.bindingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Binding>(Members)

        /** All member names as strings. */
        object Name {
            /** "binding-reference-edge" member name */
            const val bindingReferenceEdge = "binding-reference-edge"
            /** "binding-type" member name */
            const val bindingType = "binding-type"
        }

        /** Builder for immutable [Binding] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Binding) : this() {
                bindingReferenceEdge = source.bindingReferenceEdge
                bindingType = source.bindingType
            }
            /** May contain any keyword from [BindingReferenceEdge]. */
            var bindingReferenceEdge: String? = null
            /** May contain any keyword from [BindingType] or a name. */
            var bindingType: String? = null

            /** Return a new [Binding] object containing all values initialized in this builder. */
            fun build() = Binding(
                bindingReferenceEdge,
                bindingType
            )
        }

        companion object Members : AttributeCollection.Converter<Binding> {
            override fun convert(attributes: List<Attribute<*>>): Binding =
                Binding(
                    extractOne(attributes, bindingReferenceEdge),
                    extractOne(attributes, bindingType),
                    _encoded = attributes)
            /**
             * "binding-reference-edge" member type.
             * May contain any keyword from [BindingReferenceEdge].
             */
            @JvmField val bindingReferenceEdge = KeywordType(Name.bindingReferenceEdge)
            /**
             * "binding-type" member type.
             * May contain any keyword from [BindingType] or a name.
             */
            @JvmField val bindingType = KeywordType(Name.bindingType)
        }
    }

    /**
     * Data object corresponding to a "coating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Coating
    @JvmOverloads constructor(
        /** May contain any keyword from [CoatingSides]. */
        val coatingSides: String? = null,
        /** May contain any keyword from [CoatingType] or a name. */
        val coatingType: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                coatingSides?.let { Members.coatingSides.of(it) },
                coatingType?.let { Members.coatingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Coating>(Members)

        /** All member names as strings. */
        object Name {
            /** "coating-sides" member name */
            const val coatingSides = "coating-sides"
            /** "coating-type" member name */
            const val coatingType = "coating-type"
        }

        /** Builder for immutable [Coating] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Coating) : this() {
                coatingSides = source.coatingSides
                coatingType = source.coatingType
            }
            /** May contain any keyword from [CoatingSides]. */
            var coatingSides: String? = null
            /** May contain any keyword from [CoatingType] or a name. */
            var coatingType: String? = null

            /** Return a new [Coating] object containing all values initialized in this builder. */
            fun build() = Coating(
                coatingSides,
                coatingType
            )
        }

        companion object Members : AttributeCollection.Converter<Coating> {
            override fun convert(attributes: List<Attribute<*>>): Coating =
                Coating(
                    extractOne(attributes, coatingSides),
                    extractOne(attributes, coatingType),
                    _encoded = attributes)
            /**
             * "coating-sides" member type.
             * May contain any keyword from [CoatingSides].
             */
            @JvmField val coatingSides = KeywordType(Name.coatingSides)
            /**
             * "coating-type" member type.
             * May contain any keyword from [CoatingType] or a name.
             */
            @JvmField val coatingType = KeywordType(Name.coatingType)
        }
    }

    /**
     * Data object corresponding to a "covering" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Covering
    @JvmOverloads constructor(
        /** May contain any keyword from [CoveringName] or a name. */
        val coveringName: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                coveringName?.let { Members.coveringName.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Covering>(Members)

        /** All member names as strings. */
        object Name {
            /** "covering-name" member name */
            const val coveringName = "covering-name"
        }

        /** Builder for immutable [Covering] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Covering) : this() {
                coveringName = source.coveringName
            }
            /** May contain any keyword from [CoveringName] or a name. */
            var coveringName: String? = null

            /** Return a new [Covering] object containing all values initialized in this builder. */
            fun build() = Covering(
                coveringName
            )
        }

        companion object Members : AttributeCollection.Converter<Covering> {
            override fun convert(attributes: List<Attribute<*>>): Covering =
                Covering(
                    extractOne(attributes, coveringName),
                    _encoded = attributes)
            /**
             * "covering-name" member type.
             * May contain any keyword from [CoveringName] or a name.
             */
            @JvmField val coveringName = KeywordType(Name.coveringName)
        }
    }

    /**
     * Data object corresponding to a "folding" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Folding
    @JvmOverloads constructor(
        /** May contain any keyword from [FoldingDirection]. */
        val foldingDirection: String? = null,
        val foldingOffset: Int? = null,
        /** May contain any keyword from [FoldingReferenceEdge]. */
        val foldingReferenceEdge: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                foldingDirection?.let { Members.foldingDirection.of(it) },
                foldingOffset?.let { Members.foldingOffset.of(it) },
                foldingReferenceEdge?.let { Members.foldingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Folding>(Members)

        /** All member names as strings. */
        object Name {
            /** "folding-direction" member name */
            const val foldingDirection = "folding-direction"
            /** "folding-offset" member name */
            const val foldingOffset = "folding-offset"
            /** "folding-reference-edge" member name */
            const val foldingReferenceEdge = "folding-reference-edge"
        }

        /** Builder for immutable [Folding] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Folding) : this() {
                foldingDirection = source.foldingDirection
                foldingOffset = source.foldingOffset
                foldingReferenceEdge = source.foldingReferenceEdge
            }
            /** May contain any keyword from [FoldingDirection]. */
            var foldingDirection: String? = null
            var foldingOffset: Int? = null
            /** May contain any keyword from [FoldingReferenceEdge]. */
            var foldingReferenceEdge: String? = null

            /** Return a new [Folding] object containing all values initialized in this builder. */
            fun build() = Folding(
                foldingDirection,
                foldingOffset,
                foldingReferenceEdge
            )
        }

        companion object Members : AttributeCollection.Converter<Folding> {
            override fun convert(attributes: List<Attribute<*>>): Folding =
                Folding(
                    extractOne(attributes, foldingDirection),
                    extractOne(attributes, foldingOffset),
                    extractOne(attributes, foldingReferenceEdge),
                    _encoded = attributes)
            /**
             * "folding-direction" member type.
             * May contain any keyword from [FoldingDirection].
             */
            @JvmField val foldingDirection = KeywordType(Name.foldingDirection)
            /**
             * "folding-offset" member type.
             */
            @JvmField val foldingOffset = IntType(Name.foldingOffset)
            /**
             * "folding-reference-edge" member type.
             * May contain any keyword from [FoldingReferenceEdge].
             */
            @JvmField val foldingReferenceEdge = KeywordType(Name.foldingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "laminating" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Laminating
    @JvmOverloads constructor(
        /** May contain any keyword from [LaminatingSides]. */
        val laminatingSides: String? = null,
        /** May contain any keyword from [LaminatingType] or a name. */
        val laminatingType: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                laminatingSides?.let { Members.laminatingSides.of(it) },
                laminatingType?.let { Members.laminatingType.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Laminating>(Members)

        /** All member names as strings. */
        object Name {
            /** "laminating-sides" member name */
            const val laminatingSides = "laminating-sides"
            /** "laminating-type" member name */
            const val laminatingType = "laminating-type"
        }

        /** Builder for immutable [Laminating] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Laminating) : this() {
                laminatingSides = source.laminatingSides
                laminatingType = source.laminatingType
            }
            /** May contain any keyword from [LaminatingSides]. */
            var laminatingSides: String? = null
            /** May contain any keyword from [LaminatingType] or a name. */
            var laminatingType: String? = null

            /** Return a new [Laminating] object containing all values initialized in this builder. */
            fun build() = Laminating(
                laminatingSides,
                laminatingType
            )
        }

        companion object Members : AttributeCollection.Converter<Laminating> {
            override fun convert(attributes: List<Attribute<*>>): Laminating =
                Laminating(
                    extractOne(attributes, laminatingSides),
                    extractOne(attributes, laminatingType),
                    _encoded = attributes)
            /**
             * "laminating-sides" member type.
             * May contain any keyword from [LaminatingSides].
             */
            @JvmField val laminatingSides = KeywordType(Name.laminatingSides)
            /**
             * "laminating-type" member type.
             * May contain any keyword from [LaminatingType] or a name.
             */
            @JvmField val laminatingType = KeywordType(Name.laminatingType)
        }
    }

    /**
     * Data object corresponding to a "media-size" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class MediaSize
    @JvmOverloads constructor(
        val xDimension: Int? = null,
        val yDimension: Int? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                xDimension?.let { Members.xDimension.of(it) },
                yDimension?.let { Members.yDimension.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<MediaSize>(Members)

        /** All member names as strings. */
        object Name {
            /** "x-dimension" member name */
            const val xDimension = "x-dimension"
            /** "y-dimension" member name */
            const val yDimension = "y-dimension"
        }

        /** Builder for immutable [MediaSize] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: MediaSize) : this() {
                xDimension = source.xDimension
                yDimension = source.yDimension
            }
            var xDimension: Int? = null
            var yDimension: Int? = null

            /** Return a new [MediaSize] object containing all values initialized in this builder. */
            fun build() = MediaSize(
                xDimension,
                yDimension
            )
        }

        companion object Members : AttributeCollection.Converter<MediaSize> {
            override fun convert(attributes: List<Attribute<*>>): MediaSize =
                MediaSize(
                    extractOne(attributes, xDimension),
                    extractOne(attributes, yDimension),
                    _encoded = attributes)
            /**
             * "x-dimension" member type.
             */
            @JvmField val xDimension = IntType(Name.xDimension)
            /**
             * "y-dimension" member type.
             */
            @JvmField val yDimension = IntType(Name.yDimension)
        }
    }

    /**
     * Data object corresponding to a "punching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Punching
    @JvmOverloads constructor(
        val punchingLocations: List<Int>? = null,
        val punchingOffset: Int? = null,
        /** May contain any keyword from [PunchingReferenceEdge]. */
        val punchingReferenceEdge: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                punchingLocations?.let { Members.punchingLocations.of(it) },
                punchingOffset?.let { Members.punchingOffset.of(it) },
                punchingReferenceEdge?.let { Members.punchingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Punching>(Members)

        /** All member names as strings. */
        object Name {
            /** "punching-locations" member name */
            const val punchingLocations = "punching-locations"
            /** "punching-offset" member name */
            const val punchingOffset = "punching-offset"
            /** "punching-reference-edge" member name */
            const val punchingReferenceEdge = "punching-reference-edge"
        }

        /** Builder for immutable [Punching] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Punching) : this() {
                punchingLocations = source.punchingLocations
                punchingOffset = source.punchingOffset
                punchingReferenceEdge = source.punchingReferenceEdge
            }
            var punchingLocations: List<Int>? = null
            var punchingOffset: Int? = null
            /** May contain any keyword from [PunchingReferenceEdge]. */
            var punchingReferenceEdge: String? = null

            /** Return a new [Punching] object containing all values initialized in this builder. */
            fun build() = Punching(
                punchingLocations,
                punchingOffset,
                punchingReferenceEdge
            )
        }

        companion object Members : AttributeCollection.Converter<Punching> {
            override fun convert(attributes: List<Attribute<*>>): Punching =
                Punching(
                    extractAll(attributes, punchingLocations),
                    extractOne(attributes, punchingOffset),
                    extractOne(attributes, punchingReferenceEdge),
                    _encoded = attributes)
            /**
             * "punching-locations" member type.
             */
            @JvmField val punchingLocations = IntType(Name.punchingLocations)
            /**
             * "punching-offset" member type.
             */
            @JvmField val punchingOffset = IntType(Name.punchingOffset)
            /**
             * "punching-reference-edge" member type.
             * May contain any keyword from [PunchingReferenceEdge].
             */
            @JvmField val punchingReferenceEdge = KeywordType(Name.punchingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "stitching" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Stitching
    @JvmOverloads constructor(
        val stitchingAngle: Int? = null,
        val stitchingLocations: List<Int>? = null,
        /** May contain any keyword from [StitchingMethod]. */
        val stitchingMethod: String? = null,
        val stitchingOffset: Int? = null,
        /** May contain any keyword from [StitchingReferenceEdge]. */
        val stitchingReferenceEdge: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                stitchingAngle?.let { Members.stitchingAngle.of(it) },
                stitchingLocations?.let { Members.stitchingLocations.of(it) },
                stitchingMethod?.let { Members.stitchingMethod.of(it) },
                stitchingOffset?.let { Members.stitchingOffset.of(it) },
                stitchingReferenceEdge?.let { Members.stitchingReferenceEdge.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Stitching>(Members)

        /** All member names as strings. */
        object Name {
            /** "stitching-angle" member name */
            const val stitchingAngle = "stitching-angle"
            /** "stitching-locations" member name */
            const val stitchingLocations = "stitching-locations"
            /** "stitching-method" member name */
            const val stitchingMethod = "stitching-method"
            /** "stitching-offset" member name */
            const val stitchingOffset = "stitching-offset"
            /** "stitching-reference-edge" member name */
            const val stitchingReferenceEdge = "stitching-reference-edge"
        }

        /** Builder for immutable [Stitching] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Stitching) : this() {
                stitchingAngle = source.stitchingAngle
                stitchingLocations = source.stitchingLocations
                stitchingMethod = source.stitchingMethod
                stitchingOffset = source.stitchingOffset
                stitchingReferenceEdge = source.stitchingReferenceEdge
            }
            var stitchingAngle: Int? = null
            var stitchingLocations: List<Int>? = null
            /** May contain any keyword from [StitchingMethod]. */
            var stitchingMethod: String? = null
            var stitchingOffset: Int? = null
            /** May contain any keyword from [StitchingReferenceEdge]. */
            var stitchingReferenceEdge: String? = null

            /** Return a new [Stitching] object containing all values initialized in this builder. */
            fun build() = Stitching(
                stitchingAngle,
                stitchingLocations,
                stitchingMethod,
                stitchingOffset,
                stitchingReferenceEdge
            )
        }

        companion object Members : AttributeCollection.Converter<Stitching> {
            override fun convert(attributes: List<Attribute<*>>): Stitching =
                Stitching(
                    extractOne(attributes, stitchingAngle),
                    extractAll(attributes, stitchingLocations),
                    extractOne(attributes, stitchingMethod),
                    extractOne(attributes, stitchingOffset),
                    extractOne(attributes, stitchingReferenceEdge),
                    _encoded = attributes)
            /**
             * "stitching-angle" member type.
             */
            @JvmField val stitchingAngle = IntType(Name.stitchingAngle)
            /**
             * "stitching-locations" member type.
             */
            @JvmField val stitchingLocations = IntType(Name.stitchingLocations)
            /**
             * "stitching-method" member type.
             * May contain any keyword from [StitchingMethod].
             */
            @JvmField val stitchingMethod = KeywordType(Name.stitchingMethod)
            /**
             * "stitching-offset" member type.
             */
            @JvmField val stitchingOffset = IntType(Name.stitchingOffset)
            /**
             * "stitching-reference-edge" member type.
             * May contain any keyword from [StitchingReferenceEdge].
             */
            @JvmField val stitchingReferenceEdge = KeywordType(Name.stitchingReferenceEdge)
        }
    }

    /**
     * Data object corresponding to a "trimming" collection.
     */
    @Suppress("RedundantCompanionReference", "unused")
    data class Trimming
    @JvmOverloads constructor(
        val trimmingOffset: Int? = null,
        /** May contain any keyword from [TrimmingReferenceEdge]. */
        val trimmingReferenceEdge: String? = null,
        /** May contain any keyword from [TrimmingType] or a name. */
        val trimmingType: String? = null,
        /** May contain any keyword from [TrimmingWhen]. */
        val trimmingWhen: String? = null,
        /** Encoded form, if known. */
        val _encoded: List<Attribute<*>>? = null
    ) : AttributeCollection {

        /** Produce an attribute list from members, or return the original [_encoded] attribute list if present. */
        override val attributes: List<Attribute<*>> by lazy {
            _encoded ?: listOfNotNull(
                trimmingOffset?.let { Members.trimmingOffset.of(it) },
                trimmingReferenceEdge?.let { Members.trimmingReferenceEdge.of(it) },
                trimmingType?.let { Members.trimmingType.of(it) },
                trimmingWhen?.let { Members.trimmingWhen.of(it) }
            )
        }

        /** Type for attributes of this collection */
        class Type(override val name: String) : AttributeCollection.Type<Trimming>(Members)

        /** All member names as strings. */
        object Name {
            /** "trimming-offset" member name */
            const val trimmingOffset = "trimming-offset"
            /** "trimming-reference-edge" member name */
            const val trimmingReferenceEdge = "trimming-reference-edge"
            /** "trimming-type" member name */
            const val trimmingType = "trimming-type"
            /** "trimming-when" member name */
            const val trimmingWhen = "trimming-when"
        }

        /** Builder for immutable [Trimming] objects. */
        class Builder() {
            /** Constructs a new [Builder] pre-initialized with values in [source]. */
            constructor(source: Trimming) : this() {
                trimmingOffset = source.trimmingOffset
                trimmingReferenceEdge = source.trimmingReferenceEdge
                trimmingType = source.trimmingType
                trimmingWhen = source.trimmingWhen
            }
            var trimmingOffset: Int? = null
            /** May contain any keyword from [TrimmingReferenceEdge]. */
            var trimmingReferenceEdge: String? = null
            /** May contain any keyword from [TrimmingType] or a name. */
            var trimmingType: String? = null
            /** May contain any keyword from [TrimmingWhen]. */
            var trimmingWhen: String? = null

            /** Return a new [Trimming] object containing all values initialized in this builder. */
            fun build() = Trimming(
                trimmingOffset,
                trimmingReferenceEdge,
                trimmingType,
                trimmingWhen
            )
        }

        companion object Members : AttributeCollection.Converter<Trimming> {
            override fun convert(attributes: List<Attribute<*>>): Trimming =
                Trimming(
                    extractOne(attributes, trimmingOffset),
                    extractOne(attributes, trimmingReferenceEdge),
                    extractOne(attributes, trimmingType),
                    extractOne(attributes, trimmingWhen),
                    _encoded = attributes)
            /**
             * "trimming-offset" member type.
             */
            @JvmField val trimmingOffset = IntType(Name.trimmingOffset)
            /**
             * "trimming-reference-edge" member type.
             * May contain any keyword from [TrimmingReferenceEdge].
             */
            @JvmField val trimmingReferenceEdge = KeywordType(Name.trimmingReferenceEdge)
            /**
             * "trimming-type" member type.
             * May contain any keyword from [TrimmingType] or a name.
             */
            @JvmField val trimmingType = KeywordType(Name.trimmingType)
            /**
             * "trimming-when" member type.
             * May contain any keyword from [TrimmingWhen].
             */
            @JvmField val trimmingWhen = KeywordType(Name.trimmingWhen)
        }
    }
}
